<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Loading...</title>
    <script>
        // Immediately fetch config and update title
        (async function() {
            try {
                const response = await fetch('/config');
                const config = await response.json();
                if (config.appName) {
                    document.title = config.appName;
                }
            } catch (error) {
                console.error('Error fetching initial config:', error);
            }
        })();
    </script>
    <style>
        :root {
            /* Dark theme (default) */
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --text-labels: #e0e0e0;
            --accent-color: #4CAF50;
            --error-color: #f44336;
            --accent: #4CAF50;
            --accent-hover: #3ea043;
            --success: #00C851;
            --input-bg: rgba(30, 30, 30, 0.9);
            --input-border: rgba(60, 60, 60, 0.8);
            --shadow-subtle: 0 8px 16px rgba(0, 0, 0, 0.4);
            --shadow-strong: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        /* Light theme */
        :root.light-mode {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #eaeaea;
            --text-primary: #121212;
            --text-secondary: #555555;
            --text-labels: #333333;
            --input-bg: rgba(240, 240, 240, 0.9);
            --input-border: rgba(200, 200, 200, 0.8);
            --shadow-subtle: 0 8px 16px rgba(0, 0, 0, 0.1);
            --shadow-strong: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        /* Light mode specific adjustments */
        :root.light-mode .container {
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        :root.light-mode pre {
            background-color: rgba(0, 0, 0, 0.04);
            color: #333;
        }

        :root.light-mode select option {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        :root.light-mode .corpus-container button,
        :root.light-mode .delete-button {
            background: rgba(240, 240, 240, 0.9);
        }

        :root.light-mode .corpus-container button svg,
        :root.light-mode .delete-button svg {
            stroke: #555;
        }

        :root.light-mode .theme-icon svg {
            stroke: #555;
        }

        :root.light-mode input:focus, 
        :root.light-mode textarea:focus, 
        :root.light-mode select:focus {
            background-color: rgba(250, 250, 250, 1);
        }

        /* Add theme transition for smooth switching */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            max-width: 100%; /* Changed from 700px to 100% to use full viewport width */
            margin: 0;
            padding: 0; /* Reset all body padding */
            line-height: 1.5;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex; /* Changed from grid to flex */
            flex-direction: column; /* Stack children vertically */
            align-items: center; /* Center children horizontally */
            justify-content: flex-start; /* Align to top */
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
            box-sizing: border-box; /* Ensure padding is included in width calculations */
        }

        .container {
            background-color: var(--bg-secondary);
            border-radius: 12px;
            padding: 25px 30px;
            margin-bottom: 22px;
            box-shadow: var(--shadow-subtle);
            transition: box-shadow 0.3s ease;
            width: 100%;
            max-width: 640px;
            box-sizing: border-box;
            border: 1px solid var(--input-border);
        }

        .container:hover {
            box-shadow: var(--shadow-strong);
        }

        h1, h2 {
            color: var(--text-primary);
            margin-bottom: 25px;
            text-align: center;
        }

        h1 {
            font-size: 2.2em;
            font-weight: 700;
            margin-bottom: 10px;
            margin-top: 0;
            text-align: center;
            letter-spacing: -0.5px;
        }

        h2 {
            font-size: 1.6em;
            letter-spacing: -0.3px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
            text-align: center;
        }

        label {
            display: block;
            margin-bottom: 8px;
            text-align: center;
            color: var(--text-labels);
            font-weight: 600;
            font-size: 1.05em;
            letter-spacing: 0.5px;
        }

        input, textarea, select {
            width: 100%;
            padding: 14px;
            margin: 8px 0 22px;
            border: 1px solid var(--input-border);
            border-radius: 10px;
            box-sizing: border-box;
            background-color: var(--input-bg);
            color: var(--text-primary);
            transition: all 0.3s ease;
            font-size: 15px;
            text-align: center;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        textarea {
            text-align: left; /* Keep textarea left-aligned for better readability of multi-line content */
            resize: vertical; /* Only allow vertical resizing */
        }
        
        input[type="text"] {
            font-family: monospace; /* Bring back monospace font for text inputs */
        }
        
        input[type="tel"] {
            font-family: monospace; /* Apply monospace to telephone inputs too */
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.25);
            background-color: rgba(35, 35, 35, 1);
        }

        button {
            padding: 12px 24px;
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            letter-spacing: 0.2px;
        }
        
        button:hover {
            background-color: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .result {
            margin-top: 25px;
            padding: 20px;
            border-left: 4px solid var(--accent);
            background-color: rgba(76, 175, 80, 0.08);
            border-radius: 0 10px 10px 0;
            transition: all 0.5s ease;
            opacity: 1;
            transform: translateY(0);
            -webkit-text-size-adjust: 100%; /* Prevent iOS from adjusting text size */
            transform-origin: top center; /* Set transform origin to top center */
        }
        
        .result.success {
            border-left: 4px solid var(--accent);
            background-color: rgba(76, 175, 80, 0.08);
        }
        
        .result.error {
            border-left: 4px solid var(--error-color);
            background-color: rgba(244, 67, 54, 0.08);
        }

        .result.refreshing {
            opacity: 0;
            transform: translateY(10px);
        }

        /* Animation for result content */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Pulse animation for result box */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }

        /* Error pulse animation */
        @keyframes pulseError {
            0% {
                box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(244, 67, 54, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(244, 67, 54, 0);
            }
        }

        /* Apply animation to result content */
        .result pre {
            animation: fadeInUp 0.5s ease-out;
        }
        
        .result.success:not(.refreshing) {
            animation: pulse 1.5s ease-out;
        }
        
        .result.error:not(.refreshing) {
            animation: pulseError 1.5s ease-out;
        }

        .hidden {
            display: none !important;
        }

        pre {
            background-color: rgba(10, 10, 10, 0.6);
            padding: 16px;
            border-radius: 10px;
            overflow-x: auto;
            color: var(--text-secondary);
            font-family: 'Monaco', 'Consolas', monospace;
            margin: 15px 0;
        }

        #serverStatus {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 500;
            margin: 10px 0;
        }

        #serverStatus.online {
            background-color: var(--success);
            color: white;
        }

        #serverStatus.offline {
            background-color: var(--error-color);
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 8px;
            margin-top: 0;
            padding-top: 5px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .logo-container {
            margin-bottom: 2px;
        }

        .logo {
            max-width: 80px;
            height: auto;
            border-radius: 6px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
        }

        .description {
            color: var(--text-secondary);
            font-size: 1.1em;
            margin-bottom: 30px;
            text-align: center;
        }

        .help-text {
            display: block;
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-top: -15px;
            margin-bottom: 18px;
            text-align: center;
            opacity: 0.9;
        }

        h3 {
            color: var(--text-primary);
            margin: 20px 0 15px;
            text-align: center;
            font-weight: 700;
            font-size: 1.4em;
            position: relative;
        }
        
        h3::after {
            content: '';
            display: block;
            width: 120px;
            height: 3px;
            background: linear-gradient(to right, transparent, var(--accent-color), transparent);
            margin: 12px auto 0;
            border-radius: 3px;
        }
        
        h4 {
            color: var(--text-primary);
            margin: 25px 0 18px;
            text-align: center;
            font-weight: 600;
            font-size: 1.3em;
        }

        small {
            display: block;
            color: var(--text-secondary);
            margin-top: -18px;
            margin-bottom: 20px;
            text-align: center;
            font-style: italic;
        }

        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 14px center;
            background-size: 12px;
            padding-right: 30px;
        }

        select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
            background-color: rgba(25, 25, 25, 1);
        }

        select option {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            padding: 12px;
        }

        .mt-20 {
            margin-top: 20px;
        }

        .link-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .link-container input {
            flex-grow: 1;
            margin-bottom: 10px;
            background-color: rgba(20, 20, 20, 0.5);
            border-color: var(--accent);
            border-width: 1px;
            font-family: monospace;
        }

        .link-container button {
            margin-top: 8px;
            padding: 0 15px;
            height: 40px;
        }

        #outboundForm {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        
        #outboundForm > div {
            width: 100%;
            max-width: 600px;
            margin-bottom: 10px;
            position: relative;
        }
        
        #outboundForm button[type="submit"] {
            min-width: 220px;
            margin-top: 30px;
            font-size: 1.1em;
            background: linear-gradient(to bottom right, var(--accent), var(--accent-hover));
            padding: 14px 28px;
        }
        
        #outboundForm button[type="submit"]:hover {
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        
        /* Add a subtle divider between form fields */
        #outboundForm > div::after {
            content: '';
            display: block;
            height: 1px;
            width: 60%;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.05), transparent);
            margin: 0 auto;
            margin-bottom: 10px;
        }
        
        /* Don't show divider after the last form field */
        #outboundForm > div:last-of-type::after {
            display: none;
        }
        
        #shareableLinkContainer small {
            margin-top: 15px;
            opacity: 0.8;
            font-style: italic;
            display: block;
            clear: both;
        }

        /* Loading spinner styles */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
            vertical-align: middle;
        }

        button .spinner {
            width: 14px;
            height: 14px;
            border-width: 2px;
            margin-left: 8px;
            vertical-align: middle;
            position: relative;
            top: -1px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .form-group {
            margin-bottom: 15px;
            width: 100%;
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        /* Corpus container styles */
        .corpus-container {
            display: flex;
            gap: 8px;
            width: 100%;
            align-items: center;
        }

        .corpus-container select {
            flex-grow: 1;
            margin-bottom: 0;
            margin-left: 6px;
        }

        .corpus-container button {
            min-width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 8px;
            border-radius: 6px;
            background: rgba(40, 40, 40, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .corpus-container button svg {
            stroke: #b3b3b3;
            transition: stroke 0.3s ease;
        }

        #refreshCorpusBtn:hover {
            background: rgba(76, 175, 80, 0.15);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        #refreshCorpusBtn:hover svg {
            stroke: var(--accent);
        }

        /* Corpus status indicators in dropdown */
        .corpus-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .corpus-status-ready {
            background-color: var(--success);
        }

        .corpus-status-processing {
            background-color: orange;
        }

        .corpus-status-empty {
            background-color: #555;
        }

        .corpus-status-error {
            background-color: var(--error-color);
        }

        /* Add spacing for corpus help text */
        .corpus-help-text {
            margin-top: 10px;
        }

        .delete-button {
            background: rgba(40, 40, 40, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0;
            cursor: pointer;
            outline: none;
            margin-left: 10px;
            transition: all 0.3s ease;
        }
        
        .delete-button svg {
            stroke: #b3b3b3;
            transition: stroke 0.3s ease;
        }
        
        .delete-button:hover {
            background: rgba(244, 67, 54, 0.15);
            border-color: var(--error-color);
            transform: translateY(-2px);
        }
        
        .delete-button:hover svg {
            stroke: var(--error-color);
        }
        
        .delete-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: transparent;
        }
        
        .delete-button:disabled svg {
            stroke: #555;
        }

        .delete-confirmation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .delete-confirmation-content {
            background-color: var(--bg-secondary);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .delete-confirmation h3 {
            margin-top: 0;
        }
        
        .delete-confirmation-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .delete-confirmation-buttons button {
            min-width: 100px;
        }
        
        .cancel-button {
            background-color: #555;
        }
        
        .confirm-delete-button {
            background-color: var(--error-color);
        }

        /* Theme Toggle Switch Styles */
        .theme-switch-wrapper {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            background-color: rgba(0, 0, 0, 0.12);
            padding: 4px 6px 4px 6px; /* More balanced padding top and bottom */
            border-radius: 30px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(4px);
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        
        :root.light-mode .theme-switch-wrapper {
            background-color: rgba(255, 255, 255, 0.15);
        }
        
        .theme-switch-wrapper:hover {
            opacity: 1;
        }

        .theme-switch {
            display: inline-block;
            height: 16px;
            position: relative;
            width: 32px;
            margin: 0; /* Reset margin */
        }

        .theme-switch input {
            display: none;
        }

        .slider {
            background-color: rgba(0, 0, 0, 0.5);
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: 0.3s;
            border-radius: 30px;
        }

        .slider:before {
            background-color: #fff;
            bottom: 1px;
            content: "";
            height: 14px;
            left: 2px;
            position: absolute;
            transition: 0.3s;
            width: 14px;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent);
        }

        input:checked + .slider:before {
            transform: translateX(14px);
        }

        .theme-icon {
            margin: 0;
            font-size: 0.75rem;
            line-height: 1;
            opacity: 0.8;
            position: relative;
            top: 0px; /* Center the icons */
        }
        
        .theme-icon svg {
            stroke: #fff;
            vertical-align: middle;
        }

        .phone-input-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .phone-prefix {
            position: absolute;
            left: 10px;
            color: #333;
            font-size: 16px;
            z-index: 1;
        }

        input[type="tel"] {
            padding-left: 25px !important;
        }

        /* Recording Interface Styles */
        .recording-interface {
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
        }

        .mic-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .mic-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            border: 2px solid var(--accent);
        }

        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }

        .mic-icon {
            width: 40px;
            height: 40px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234CAF50' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z'%3E%3C/path%3E%3Cpath d='M19 10v2a7 7 0 0 1-14 0v-2'%3E%3C/path%3E%3Cline x1='12' y1='19' x2='12' y2='23'%3E%3C/line%3E%3Cline x1='8' y1='23' x2='16' y2='23'%3E%3C/line%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            transition: all 0.3s ease;
        }

        .recording-rings {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .ring {
            position: absolute;
            border-radius: 50%;
            border: 2px solid var(--accent);
            width: 100%;
            height: 100%;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            opacity: 0;
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .ring2 { animation-delay: 0.6s; }
        .ring3 { animation-delay: 1.2s; }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 0.5;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        .recording .recording-rings {
            opacity: 1;
        }

        .recording .mic-icon {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23f44336' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='3' y='3' width='18' height='18' rx='2' ry='2'%3E%3C/rect%3E%3C/svg%3E");
        }

        .recording .mic-button {
            border-color: #f44336;
            animation: recording-pulse 2s ease infinite;
        }

        @keyframes recording-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4);
            }
            70% {
                box-shadow: 0 0 0 15px rgba(244, 67, 54, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(244, 67, 54, 0);
            }
        }

        #recordingStatus {
            font-size: 1.1em;
            color: var(--text-secondary);
        }

        #recordingTimer {
            font-family: monospace;
            font-size: 1.2em;
            color: var(--accent);
            font-weight: bold;
        }

        #recordingTimer.warning {
            color: #ffa726;
        }

        #recordingTimer.danger {
            color: #f44336;
        }

        #recordingControls, #previewControls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .danger-button {
            background-color: #f44336;
        }

        .danger-button:hover {
            background-color: #d32f2f;
        }

        .success-button {
            background-color: var(--success);
        }

        .success-button:hover {
            background-color: #00a844;
        }

        audio {
            margin: 15px auto;
            width: 100%;
            max-width: 300px;
            display: block;
        }

        /* Style audio player */
        audio::-webkit-media-controls-panel {
            background-color: var(--bg-tertiary);
        }

        audio::-webkit-media-controls-current-time-display,
        audio::-webkit-media-controls-time-remaining-display {
            color: var(--text-primary);
        }

        /* File input styling */
        input[type="file"] {
            width: auto;
            max-width: 80%;
            margin: 8px auto;
            padding: 10px;
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            display: inline-block;
            text-align: center;
            border: 1px solid var(--input-border);
            transition: all 0.3s ease;
        }

        input[type="file"]:hover {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        /* Light mode adjustments for file input */
        :root.light-mode input[type="file"] {
            background-color: #e8e8e8;
            color: var(--text-primary);
        }

        :root.light-mode input[type="file"]:hover {
            background-color: var(--accent-color);
            color: white;
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            .result {
                font-size: 14px; /* Slightly smaller font on mobile */
                padding: 15px;
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            }
            
            pre {
                font-size: 12px; /* Smaller code font on mobile */
                word-break: break-word; /* Prevent horizontal scrolling */
                white-space: pre-wrap; /* Allow wrapping */
            }
            
            /* Prevent input zoom on iOS */
            input, select, textarea {
                font-size: 16px !important; /* Minimum font size to prevent zoom on iOS */
            }
            
            /* Improve button tap targets on mobile */
            button {
                min-height: 44px; /* Apple's recommended minimum touch target size */
            }
        }

        /* Password Protection Styles */
        .password-protection {
            text-align: center;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .password-protection p {
            font-size: 1.1em !important;
            color: var(--text-primary) !important;
            margin-bottom: 15px !important;
            font-weight: normal !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif !important;
            letter-spacing: normal !important;
        }

        .password-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .password-input-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 300px;
            gap: 10px;
            align-items: center;
        }

        .password-input-container input {
            margin: 0;
            text-align: center;
            width: 100%;
        }

        .password-input-container button {
            margin: 0;
            min-width: 120px;
            align-self: center;
        }

        .section-content {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.5s ease, opacity 0.5s ease, padding 0.5s ease;
            padding: 0;
        }

        .section-content.unlocked {
            max-height: 5000px; /* Large enough to contain all content */
            opacity: 1;
            padding: 20px 0 0 0;
        }

        .lock-icon {
            display: inline-block;
            margin-left: 10px !important; 
            vertical-align: middle;
            transition: all 0.3s ease;
            opacity: 1;
        }

        .lock-icon svg {
            stroke: var(--text-secondary);
        }

        .lock-icon.hidden {
            opacity: 0;
            width: 0;
            margin-left: 0;
        }

        .password-error {
            color: var(--error-color);
            font-size: 0.9em;
            margin-top: 5px;
            opacity: 0;
            transition: opacity 0.3s ease;
            height: 0;
            overflow: hidden;
        }

        .password-error.visible {
            opacity: 1;
            height: auto;
            margin-bottom: 10px;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .section-header h2 {
            margin-bottom: 0 !important;
            font-size: 1.6em !important;
            font-weight: 600 !important;
            letter-spacing: -0.3px !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif !important;
            color: var(--text-primary) !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo-container">
            <img id="appLogo" src="https://brand.aipowergrid.io/_data/i/upload/2024/03/14/20240314185634-06dfd4e5-2s.png" alt="App Logo" class="logo">
        </div>
        <h1 id="appName">AI Voice Agent</h1>
        
        <!-- Theme toggle switch -->
        <div class="theme-switch-wrapper">
            <span class="theme-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
            </span>
            <label class="theme-switch" for="checkbox">
                <input type="checkbox" id="checkbox" />
                <div class="slider"></div>
            </label>
            <span class="theme-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </span>
        </div>
    </div>

    <div class="container">
        <h2>Make Outbound Call</h2>
        <form id="outboundForm">
            <div>
                <label for="phoneNumber">Phone Number</label>
                <div class="phone-input-container">
                    <input type="tel" id="phoneNumber" name="phoneNumber" placeholder="1234567890" inputmode="tel" pattern="[0-9\s\-\(\)\+]{5,}" required>
                </div>
                <small class="help-text">Enter 10 digit US phone number or 11 digit international number with country code</small>
            </div>
            <div>
                <label for="voiceId">Voice</label>
                <select id="voiceId" name="voiceId">
                    <option value="">Loading voices...</option>
                </select>
                <small class="help-text">Select a voice for the AI assistant</small>
            </div>
            <div>
                <label for="corpusId">Knowledge Base (optional)</label>
                <div class="corpus-container">
                    <button type="button" id="refreshCorpusBtn" title="Refresh corpus list">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
                        </svg>
                    </button>
                    <select id="corpusId" name="corpusId">
                        <option value="">No corpus (RAG disabled)</option>
                        <!-- Corpus options will be loaded dynamically -->
                    </select>
                    <button type="button" id="deleteCorpusBtn" title="Delete selected corpus" class="delete-button" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                        </svg>
                    </button>
                </div>
                <small class="help-text corpus-help-text">Select a knowledge base corpus or none to disable RAG</small>
            </div>
            <div>
                <label for="tools">Tools (optional)</label>
                <input type="text" id="tools" name="tools" placeholder="Leave empty to disable tools">
                <small class="help-text">Empty = tools disabled, comma-separated list = specific tools enabled i.e 'hangup,time'</small>
            </div>
            <div>
                <label for="agentName">Agent Name</label>
                <input type="text" id="agentName" name="agentName" placeholder="Leave empty to use default (Loddie)">
                <small class="help-text">The name agent will introduce itself as</small>
            </div>
            <div>
                <label for="systemPrompt">System Prompt</label>
                <textarea id="systemPrompt" name="systemPrompt" rows="13" placeholder="Default: You are playing the role of a naive and gullible person who is easily scammed. Your goal is to waste scammers' time by acting interested but confused. Speak slowly, ask repetitive questions, and pretend to have technical difficulties. Make them explain things multiple times. Act like you're eager to send money but keep finding excuses to delay. Use phrases like 'Oh gosh, I'm not very good with computers' and 'Can you explain that again? I want to make sure I do it right.' Keep them on the line as long as possible. Only use the hangUp tool if you've engaged with them for at least 5 minutes and there's a natural conclusion to the call.'

Leave empty to use the above prompt."></textarea>
            </div>
            <div class="form-group">
                <button type="submit" id="submitBtn">Initiate Call<span id="loadingSpinner" class="spinner hidden"></span></button>
            </div>
        </form>
        <div id="outboundResult" class="result hidden">
            <h3>Result:</h3>
            <pre id="outboundResultContent"></pre>
            <div id="shareableLinkContainer" class="mt-20 hidden">
                <h4>Shareable Link:</h4>
                <div class="link-container">
                    <input type="text" id="shareableLink" readonly>
                    <button id="copyLinkBtn">Copy</button>
                </div>
                <small>Share this link to pre-fill the form with these values</small>
            </div>
        </div>
    </div>

    <!-- Voice Cloning Section - MOVED BEFORE CORPUS SECTION -->
    <div class="container">
        <div class="section-header" id="voiceCloneHeader">
            <h2 style="font-style: normal !important; font-size: 1.6em !important;">Clone Voice</h2>
            <span class="lock-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
            </span>
        </div>
        
        <div class="password-protection" id="voiceCloneProtection">
            <p style="font-style: normal !important;">Enter Password to Access</p>
            <div class="password-form">
                <div class="password-input-container">
                    <input type="password" id="voiceClonePassword" placeholder="Enter password">
                    <button type="button" id="voiceCloneUnlock">Unlock</button>
                </div>
                <div class="password-error" id="voiceCloneError">Incorrect password</div>
            </div>
        </div>
        
        <div class="section-content" id="voiceCloneContent">
            <!-- Audio Recording Interface -->
            <div class="recording-interface" style="text-align: center; margin-bottom: 30px;">
                <div class="mic-container">
                    <div class="mic-button">
                        <div class="mic-icon"></div>
                        <div class="recording-rings">
                            <div class="ring ring1"></div>
                            <div class="ring ring2"></div>
                            <div class="ring ring3"></div>
                        </div>
                    </div>
                    <div id="recordingStatus">Click to start recording</div>
                    <div id="recordingTimer" class="hidden">00:00</div>
                    <div id="recordingControls" class="hidden">
                        <button id="stopRecording" class="danger-button">Stop Recording</button>
                        <button id="cancelRecording" class="cancel-button">Cancel</button>
                    </div>
                    <audio id="recordingPreview" controls class="hidden"></audio>
                    <div id="previewControls" class="hidden">
                        <button id="useRecording" class="success-button">Use Recording</button>
                        <button id="discardRecording" class="cancel-button">Discard</button>
                    </div>
                </div>
            </div>
            
            <!-- Audio File Upload Section -->
            <div>
                <label for="audioFile">Or Upload Audio File</label>
                <div style="text-align: center; margin-bottom: 15px;">
                    <input type="file" id="audioFile" name="audioFile" accept=".mp3,.wav" style="margin: 0 auto;">
                </div>
                <small class="help-text">Optional: Upload a WAV or MP3 file (max 10MB).</small>
            </div>
            
            <!-- Renamed from "Requirements" to "Recommendations" -->
            <div class="requirements-box" style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <h4 style="margin-top: 0; margin-bottom: 10px;">Audio Recommendations:</h4>
                <ul style="margin-top: 0; margin-bottom: 0; list-style: none; padding-left: 0; display: inline-block; text-align: left;">
                    <li style="margin-bottom: 8px;"><span style="display: inline-block; width: 25px; text-align: center;">📝</span> 30-60 seconds of clear speech</li>
                    <li style="margin-bottom: 8px;"><span style="display: inline-block; width: 25px; text-align: center;">🎤</span> Single speaker, no background voices</li>
                    <li style="margin-bottom: 8px;"><span style="display: inline-block; width: 25px; text-align: center;">🔇</span> No background noise, music, or echo</li>
                    <li style="margin-bottom: 0;"><span style="display: inline-block; width: 25px; text-align: center;">🗣️</span> Natural speaking pace and tone</li>
                </ul>
            </div>

            <form id="voiceCloneForm">
                <div>
                    <label for="voiceName">Voice Name</label>
                    <input type="text" id="voiceName" name="voiceName" placeholder="My Custom Voice" required>
                </div>
                <div>
                    <label for="voiceDescription">Description (optional)</label>
                    <input type="text" id="voiceDescription" name="voiceDescription" placeholder="Voice recorded on Jan 1, 2024">
                </div>
                <small style="color: #f44336; font-weight: bold; margin-top: 5px; margin-bottom: 15px; text-align: center; display: block;">Creating a new voice will DELETE previously cloned voice! Please allow up to 2-3 minutes for the new voice to be ready and do not refresh the page!
                <div class="form-group">
                    <button type="submit" id="cloneVoiceBtn">Clone Voice<span id="voiceLoadingSpinner" class="spinner hidden"></span></button>
                </div>
            </form>
            <div id="voiceCloneResult" class="result hidden">
                <h3>Voice Cloning Result:</h3>
                <pre id="voiceCloneResultContent"></pre>
            </div>
        </div>
    </div>

    <!-- Corpus Creation Section - MOVED AFTER VOICE CLONING -->
    <div class="container">
        <div class="section-header" id="corpusHeader">
            <h2 style="font-style: normal !important; font-size: 1.6em !important;">Knowledge Base</h2>
            <span class="lock-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
            </span>
        </div>
        
        <div class="password-protection" id="corpusProtection">
            <p style="font-style: normal !important;">Enter Password to Access</p>
            <div class="password-form">
                <div class="password-input-container">
                    <input type="password" id="corpusPassword" placeholder="Enter password">
                    <button type="button" id="corpusUnlock">Unlock</button>
                </div>
                <div class="password-error" id="corpusError">Incorrect password</div>
            </div>
        </div>
        
        <div class="section-content" id="corpusContent">
            <form id="corpusForm">
                <div>
                    <label for="corpusName">Corpus Name</label>
                    <input type="text" id="corpusName" name="corpusName" placeholder="MyKnowledgeBase" required>
                </div>
                <div>
                    <label for="corpusDescription">Description (optional)</label>
                    <input type="text" id="corpusDescription" name="corpusDescription" placeholder="Description of this knowledge base">
                </div>
                <div>
                    <label for="corpusUrls">Website URLs</label>
                    <textarea id="corpusUrls" name="corpusUrls" rows="3" placeholder="https://example.com/page1,&#10;https://github.com/username/repo/README.md,&#10;https://docs.yourdomain.com/info"></textarea>
                    <small class="help-text">Add comma-separated URLs for websites you want to include in this corpus. Best with informative text content like documentation and GitHub README files.</small>
                </div>
                <div class="form-group">
                    <button type="submit" id="createCorpusBtn">Create Corpus<span id="corpusLoadingSpinner" class="spinner hidden"></span></button>
                </div>
            </form>
            <div id="corpusResult" class="result hidden">
                <h3>Corpus Creation Result:</h3>
                <pre id="corpusResultContent"></pre>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Dialog -->
    <div id="deleteConfirmation" class="delete-confirmation hidden">
        <div class="delete-confirmation-content">
            <h3>Delete Corpus</h3>
            <p>Are you sure you want to delete the corpus "<span id="deleteCorpusName"></span>"?</p>
            <p>This action cannot be undone, and all associated data will be permanently deleted.</p>
            <div class="delete-confirmation-buttons">
                <button id="cancelDeleteBtn" class="cancel-button">Cancel</button>
                <button id="confirmDeleteBtn" class="confirm-delete-button">Delete</button>
            </div>
        </div>
    </div>

    <script>
        // Theme switching functionality
        document.addEventListener('DOMContentLoaded', function() {
            const toggleSwitch = document.querySelector('#checkbox');
            const currentTheme = localStorage.getItem('theme');
            
            // Check if user had previously selected a theme
            if (currentTheme) {
                document.documentElement.classList.toggle('light-mode', currentTheme === 'light');
                toggleSwitch.checked = currentTheme === 'light';
            }
            
            // Listen for toggle switch change
            toggleSwitch.addEventListener('change', function(e) {
                if (e.target.checked) {
                    document.documentElement.classList.add('light-mode');
                    localStorage.setItem('theme', 'light');
                } else {
                    document.documentElement.classList.remove('light-mode');
                    localStorage.setItem('theme', 'dark');
                }
            });
        });
        
        // Fetch configuration
        async function fetchConfig() {
            try {
                const response = await fetch('/config');
                const config = await response.json();
                
                // Update logo and app name
                const logoElement = document.getElementById('appLogo');
                if (logoElement && config.logoUrl) {
                    logoElement.src = config.logoUrl;
                    logoElement.alt = config.appName || 'App Logo';
                }
                
                const appNameElement = document.getElementById('appName');
                if (appNameElement && config.appName) {
                    appNameElement.textContent = config.appName;
                    document.title = config.appName;
                }
                
                return config;
            } catch (error) {
                console.error('Error fetching configuration:', error);
                return {};
            }
        }

        // Function to check server status
        async function checkServerStatus() {
            try {
                const response = await fetch('/health');
                if (response.ok) {
                    const data = await response.json();
                    console.log('Server status:', data);
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Server health check failed:', error);
                return false;
            }
        }

        // Initialize configuration on page load
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Fetch configuration first
                await fetchConfig();
                
                // Load available voices
                await loadVoices();
                
                // Load available corpora
                await loadCorpora();
                
                // Add form submit handlers
                const outboundForm = document.getElementById('outboundForm');
                if (outboundForm) {
                    outboundForm.addEventListener('submit', function(e) {
                        e.preventDefault();
                        submitOutboundForm(e);
                    });
                }

                // Add voice clone form handler
                const voiceCloneForm = document.getElementById('voiceCloneForm');
                if (voiceCloneForm) {
                    voiceCloneForm.addEventListener('submit', async function(e) {
                        e.preventDefault();
                        await submitVoiceCloneForm(e);
                    });
                }
                
                // Parse URL parameters
                parseURLParams();
                
                // Set up corpus creation form
                setupCorpusForm();
                
                // Setup refresh button
                const refreshCorpusBtn = document.getElementById('refreshCorpusBtn');
                if (refreshCorpusBtn) {
                    refreshCorpusBtn.addEventListener('click', function() {
                        loadCorpora(true);
                    });
                }
            } catch (error) {
                console.error("Error during initialization:", error);
            }
        });

        // Function to parse URL parameters and fill the form
        function parseURLParams() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Map URL parameters to form field IDs
            const paramMap = {
                'phone': 'phoneNumber',
                'voice': 'voiceId',
                'corpus': 'corpusId',
                'tools': 'tools',
                'agent': 'agentName',
                'prompt': 'systemPrompt'
            };
            
            // Fill form fields based on URL parameters
            for (const [param, fieldId] of Object.entries(paramMap)) {
                if (urlParams.has(param)) {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        if (field.tagName === 'TEXTAREA') {
                            field.value = decodeURIComponent(urlParams.get(param));
                        } else if (field.tagName === 'SELECT') {
                            // For select elements, we need to wait until options are loaded
                            // This is handled in the loadVoices and loadCorpora functions
                        } else {
                            field.value = decodeURIComponent(urlParams.get(param));
                        }
                    }
                }
            }
        }

        // Function to copy text to clipboard
        function copyToClipboard(text) {
            // Modern way using clipboard API if available
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        // Show feedback
                        const copyBtn = document.getElementById('copyLinkBtn');
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy: ', err);
                        // Fallback to the old method if clipboard API fails
                        fallbackCopyToClipboard(text);
                    });
            } else {
                // Fallback for browsers that don't support clipboard API
                fallbackCopyToClipboard(text);
            }
        }

        // Fallback method for older browsers
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';  // Make it invisible
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                // Show feedback
                const copyBtn = document.getElementById('copyLinkBtn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 2000);
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
            }
            
            document.body.removeChild(textArea);
        }

        async function loadVoices() {
            try {
                console.log('Loading voices...');
                const response = await fetch('/voices');
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                const voiceSelect = document.getElementById('voiceId');
                if (!voiceSelect) return;
                
                voiceSelect.innerHTML = '<option value="">Default Voice</option>';
                
                // Check if we have valid data
                if (!data.results || !Array.isArray(data.results)) {
                    console.warn('Invalid voice data format:', data);
                    return;
                }
                
                // Sort voices by name
                const voices = data.results.sort((a, b) => a.name.localeCompare(b.name));
                
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.voiceId;
                    // Add gender and language info to the name if available
                    let displayName = voice.name;
                    if (voice.gender && voice.language) {
                        displayName += ` (${voice.gender}, ${voice.language})`;
                    }
                    option.textContent = displayName;
                    if (voice.description) {
                        option.title = voice.description;
                    }
                    // Set the current voice as selected if it matches
                    if (voice.voiceId === '87edb04c-06d4-47c2-bd94-683bc47e8fbe') {
                        option.selected = true;
                    }
                    voiceSelect.appendChild(option);
                });
                
                // Now that options are loaded, set the voice if it was in URL params
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('voice')) {
                    const voiceId = urlParams.get('voice');
                    // Find the option with this value
                    const option = Array.from(voiceSelect.options).find(opt => opt.value === voiceId);
                    if (option) {
                        option.selected = true;
                    }
                }
                console.log('Voices loaded successfully');
            } catch (error) {
                console.error('Error loading voices:', error);
                const voiceSelect = document.getElementById('voiceId');
                if (voiceSelect) {
                    voiceSelect.innerHTML = '<option value="">Error loading voices</option>';
                }
            }
        }

        async function loadCorpora(refresh = false) {
            try {
                console.log('Loading corpora...');
                const response = await fetch('/list-corpora');
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Corpora data:', data);
                
                // Get the corpus select element
                const corpusSelect = document.getElementById('corpusId');
                if (!corpusSelect) return;
                
                // Save the current selection
                const currentSelected = corpusSelect.value;
                
                // Clear existing options except the first one
                while (corpusSelect.options.length > 1) {
                    corpusSelect.remove(1);
                }
                
                // Add each corpus as an option
                if (data.corpora && data.corpora.length > 0) {
                    data.corpora.forEach(corpus => {
                        const option = document.createElement('option');
                        option.value = corpus.id || corpus.corpusId; // Support both property names
                        
                        // Add status indicator
                        let statusClass = '';
                        if (corpus.stats && corpus.stats.status) {
                            const status = corpus.stats.status;
                            if (status === 'CORPUS_STATUS_READY') {
                                statusClass = 'corpus-status-ready';
                            } else if (status.includes('PROCESSING')) {
                                statusClass = 'corpus-status-processing';
                            } else if (status.includes('ERROR')) {
                                statusClass = 'corpus-status-error';
                            } else {
                                statusClass = 'corpus-status-empty';
                            }
                        } else {
                            statusClass = 'corpus-status-empty';
                        }
                        
                        option.innerHTML = `<span class="corpus-status ${statusClass}"></span> ${corpus.name}`;
                        corpusSelect.add(option);
                    });
                    
                    // Restore selection if it exists
                    if (currentSelected) {
                        corpusSelect.value = currentSelected;
                    }
                } else {
                    console.log('No corpora found or invalid data format:', data);
                }
                
                // Enable/disable delete button based on selection
                const deleteButton = document.getElementById('deleteCorpusBtn');
                if (!deleteButton) return;
                
                deleteButton.disabled = !corpusSelect.value;
                
                // Add event listeners if they don't exist
                if (!corpusSelect.hasAttribute('data-listeners-added')) {
                    // Enable/disable delete button based on corpus selection
                    corpusSelect.addEventListener('change', function() {
                        const deleteBtn = document.getElementById('deleteCorpusBtn');
                        if (deleteBtn) {
                            deleteBtn.disabled = !this.value;
                        }
                    });
                    
                    // Mark that we've added listeners
                    corpusSelect.setAttribute('data-listeners-added', 'true');
                }
                
                // Setup delete button listener if not already setup
                if (deleteButton && !deleteButton.hasAttribute('data-listeners-added')) {
                    // Delete corpus button event listener
                    deleteButton.addEventListener('click', function() {
                        const corpusSelect = document.getElementById('corpusId');
                        if (!corpusSelect) return;
                        
                        const corpusId = corpusSelect.value;
                        if (!corpusId) return;
                        
                        const selectedOption = corpusSelect.options[corpusSelect.selectedIndex];
                        const corpusName = selectedOption ? selectedOption.text : 'Unknown';
                        
                        showDeleteConfirmation(corpusId, corpusName);
                    });
                    
                    // Mark that we've added listeners
                    deleteButton.setAttribute('data-listeners-added', 'true');
                }
                
                // Refresh the corpus list if it's a manual refresh
                if (refresh) {
                    setTimeout(() => {
                        loadCorpora();
                    }, 500);
                }
                
                console.log('Corpora loaded successfully');
            } catch (error) {
                console.error('Error loading corpora:', error);
                const corpusSelect = document.getElementById('corpusId');
                if (corpusSelect) {
                    // Keep the first "No corpus" option but add an error message
                    while (corpusSelect.options.length > 1) {
                        corpusSelect.remove(1);
                    }
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "Error loading corpora";
                    option.disabled = true;
                    corpusSelect.add(option);
                }
            }
        }
        
        function setupCorpusForm() {
            // Corpus form submission handler
            const corpusForm = document.getElementById('corpusForm');
            if (corpusForm) {
                corpusForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const corpusName = document.getElementById('corpusName').value;
                    const corpusDescription = document.getElementById('corpusDescription').value;
                    const corpusUrls = document.getElementById('corpusUrls').value;
                    
                    // Get result elements
                    const resultElement = document.getElementById('corpusResult');
                    const resultContentElement = document.getElementById('corpusResultContent');
                    const loadingSpinner = document.getElementById('corpusLoadingSpinner');
                    
                    // Show loading spinner
                    loadingSpinner.classList.remove('hidden');
                    
                    // If result is already visible, add refreshing class for transition
                    if (!resultElement.classList.contains('hidden')) {
                        resultElement.classList.add('refreshing');
                        // Wait for animation to complete before updating content
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } else {
                        // Remove hidden class but keep it invisible with refreshing state
                        resultElement.classList.remove('hidden');
                        resultElement.classList.add('refreshing');
                    }
                    
                    try {
                        const response = await fetch('/create-corpus', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                name: corpusName,
                                description: corpusDescription,
                                urls: corpusUrls
                            })
                        });
                        
                        const data = await response.json();
                        
                        // Hide loading spinner
                        loadingSpinner.classList.add('hidden');
                        
                        // Update content while result is still invisible
                        resultContentElement.textContent = JSON.stringify(data, null, 2);
                        
                        // Check if the call failed and apply error styling
                        if (data.error) {
                            resultElement.classList.add('error');
                            resultElement.classList.remove('success');
                        } else {
                            resultElement.classList.add('success');
                            resultElement.classList.remove('error');
                            
                            // Refresh the corpus list
                            loadCorpora();
                            
                            // Auto-select the new corpus
                            setTimeout(() => {
                                const corpusSelect = document.getElementById('corpusId');
                                if (data.corpusId) {
                                    for (let i = 0; i < corpusSelect.options.length; i++) {
                                        if (corpusSelect.options[i].value === data.corpusId) {
                                            corpusSelect.selectedIndex = i;
                                            break;
                                        }
                                    }
                                }
                            }, 500); // Small delay to allow the corpus list to update
                        }
                        
                        // Show the result with animation
                        setTimeout(() => {
                            resultElement.classList.remove('refreshing');
                        }, 50);
                        
                    } catch (error) {
                        console.error('Error:', error);
                        
                        // Hide loading spinner
                        loadingSpinner.classList.add('hidden');
                        
                        // Update content to show error
                        resultContentElement.textContent = 'Error: ' + error.message;
                        resultElement.classList.add('error');
                        resultElement.classList.remove('success');
                        
                        // Show the result with animation
                        setTimeout(() => {
                            resultElement.classList.remove('refreshing');
                        }, 50);
                    }
                });
            }
        }

        // Handle the outbound form submission
        async function submitOutboundForm(e) {
            if (e) e.preventDefault();
            
            // Prevent scrolling during form submission
            document.body.style.overflow = 'hidden';
            
            let phoneNumber = document.getElementById('phoneNumber').value;
            
            // Clean the phone number (preserve + but remove other non-digit characters)
            let hasPlus = phoneNumber.startsWith('+');
            const cleanNumber = phoneNumber.replace(/[^\d]/g, '');
            
            // If it's a 10-digit number without prefix, add +1
            if (cleanNumber.length === 10) {
                phoneNumber = '+1' + cleanNumber;
            } else if (hasPlus) {
                // If it had a + prefix, preserve it
                phoneNumber = '+' + cleanNumber;
            } else {
                // For all other cases, ensure it has a + prefix
                phoneNumber = '+' + cleanNumber;
            }

            const systemPrompt = document.getElementById('systemPrompt').value;
            const voiceId = document.getElementById('voiceId').value;
            const corpusId = document.getElementById('corpusId').value;
            const tools = document.getElementById('tools').value.trim();
            const agentName = document.getElementById('agentName').value.trim();
            
            // Get result elements
            const resultElement = document.getElementById('outboundResult');
            const resultContentElement = document.getElementById('outboundResultContent');
            const shareableLinkContainer = document.getElementById('shareableLinkContainer');
            const loadingSpinner = document.getElementById('loadingSpinner');
            
            if (!resultElement || !resultContentElement || !loadingSpinner) {
                console.error('Required DOM elements not found');
                return;
            }
            
            // Show loading spinner
            loadingSpinner.classList.remove('hidden');
            
            // If result is already visible, add refreshing class for transition
            if (!resultElement.classList.contains('hidden')) {
                resultElement.classList.add('refreshing');
                // Wait for animation to complete before updating content
                await new Promise(resolve => setTimeout(resolve, 300));
            } else {
                // Remove hidden class but keep it invisible with refreshing state
                resultElement.classList.remove('hidden');
                resultElement.classList.add('refreshing');
            }
            
            try {
                const response = await fetch('/outgoing', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        destinationNumber: phoneNumber,
                        systemPrompt: systemPrompt || undefined,
                        voiceId: voiceId || undefined,
                        corpusId: corpusId || null,  // Explicitly send null to override env default
                        agentName: agentName || undefined,
                        tools: tools === '' ? [] : 
                               tools.toLowerCase() === 'default' ? undefined :
                               tools.split(',').map(t => t.trim())
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Hide loading spinner
                loadingSpinner.classList.add('hidden');
                
                // Update content while result is still invisible
                resultContentElement.textContent = JSON.stringify(data, null, 2);
                
                // Check if the call failed and apply error styling
                if (data.error) {
                    resultElement.classList.add('error');
                    resultElement.classList.remove('success');
                } else {
                    resultElement.classList.add('success');
                    resultElement.classList.remove('error');
                }
                
                // Generate shareable link
                if (shareableLinkContainer) {
                    const baseUrl = window.location.origin + window.location.pathname;
                    let shareableLink = baseUrl + '?';
                    
                    // Only add parameters that have values
                    if (phoneNumber) shareableLink += 'phone=' + encodeURIComponent(phoneNumber) + '&';
                    if (voiceId) shareableLink += 'voice=' + encodeURIComponent(voiceId) + '&';
                    if (corpusId) shareableLink += 'corpus=' + encodeURIComponent(corpusId) + '&';
                    if (tools) shareableLink += 'tools=' + encodeURIComponent(tools) + '&';
                    if (agentName) shareableLink += 'agent=' + encodeURIComponent(agentName) + '&';
                    if (systemPrompt) shareableLink += 'prompt=' + encodeURIComponent(systemPrompt);
                    
                    // Remove trailing '&' if needed
                    if (shareableLink.endsWith('&')) {
                        shareableLink = shareableLink.slice(0, -1);
                    }
                    
                    const shareableLinkInput = document.getElementById('shareableLink');
                    if (shareableLinkInput) {
                        shareableLinkInput.value = shareableLink;
                        shareableLinkContainer.classList.remove('hidden');
                        
                        // Make sure only one event listener is attached
                        const copyLinkBtn = document.getElementById('copyLinkBtn');
                        if (copyLinkBtn) {
                            copyLinkBtn.onclick = function() {
                                copyToClipboard(shareableLink);
                            };
                        }
                    }
                }
                
                // Show the result with animation
                setTimeout(() => {
                    resultElement.classList.remove('refreshing');
                    // Restore scrolling
                    document.body.style.overflow = '';
                    
                    // Ensure we don't zoom on mobile
                    if (window.innerWidth <= 768) {
                        // Prevent any zoom by maintaining the viewport scale
                        document.querySelector('meta[name="viewport"]').setAttribute(
                            'content', 
                            'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'
                        );
                    }
                }, 50);
                
            } catch (error) {
                console.error('Error submitting form:', error);
                
                // Hide loading spinner
                loadingSpinner.classList.add('hidden');
                
                // Update content to show error
                resultContentElement.textContent = 'Error: ' + error.message;
                resultElement.classList.add('error');
                resultElement.classList.remove('success');
                
                // Show the result with animation
                setTimeout(() => {
                    resultElement.classList.remove('refreshing');
                    // Restore scrolling
                    document.body.style.overflow = '';
                }, 50);
            }
        }

        // Function to show delete confirmation dialog
        function showDeleteConfirmation(corpusId, corpusName) {
            // Set corpus name in confirmation dialog
            document.getElementById('deleteCorpusName').textContent = corpusName;
            
            // Get dialog element and show it
            const dialog = document.getElementById('deleteConfirmation');
            dialog.classList.remove('hidden');
            
            // Set up event handlers for confirmation buttons
            document.getElementById('cancelDeleteBtn').onclick = function() {
                dialog.classList.add('hidden');
            };
            
            document.getElementById('confirmDeleteBtn').onclick = function() {
                deleteCorpus(corpusId);
                dialog.classList.add('hidden');
            };
        }
        
        // Function to delete corpus via API
        async function deleteCorpus(corpusId) {
            try {
                // Get result elements (reuse corpus result area)
                const resultElement = document.getElementById('corpusResult');
                const resultContentElement = document.getElementById('corpusResultContent');
                
                // Show loading and prepare result area
                if (!resultElement.classList.contains('hidden')) {
                    resultElement.classList.add('refreshing');
                    await new Promise(resolve => setTimeout(resolve, 300));
                } else {
                    resultElement.classList.remove('hidden');
                    resultElement.classList.add('refreshing');
                }
                
                // Call delete API
                const response = await fetch(`/corpus/${corpusId}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                // Update result content
                resultContentElement.textContent = JSON.stringify(data, null, 2);
                
                // Apply styling based on success/error
                if (data.error) {
                    resultElement.classList.add('error');
                    resultElement.classList.remove('success');
                } else {
                    resultElement.classList.add('success');
                    resultElement.classList.remove('error');
                    
                    // Refresh corpus list after successful deletion
                    loadCorpora();
                }
                
                // Show result with animation
                setTimeout(() => {
                    resultElement.classList.remove('refreshing');
                }, 50);
                
            } catch (error) {
                console.error('Error deleting corpus:', error);
                
                // Get result elements
                const resultElement = document.getElementById('corpusResult');
                const resultContentElement = document.getElementById('corpusResultContent');
                
                // Update content to show error
                resultContentElement.textContent = 'Error: ' + error.message;
                resultElement.classList.add('error');
                resultElement.classList.remove('success');
                resultElement.classList.remove('hidden');
                
                // Show result with animation
                setTimeout(() => {
                    resultElement.classList.remove('refreshing');
                }, 50);
            }
        }

        // Audio Recording Handler
        document.addEventListener('DOMContentLoaded', function() {
            let mediaRecorder;
            let audioChunks = [];
            let recordingStartTime;
            let timerInterval;
            let recordedBlob;
            
            const micButton = document.querySelector('.mic-button');
            const recordingStatus = document.getElementById('recordingStatus');
            const recordingTimer = document.getElementById('recordingTimer');
            const recordingControls = document.getElementById('recordingControls');
            const previewControls = document.getElementById('previewControls');
            const recordingPreview = document.getElementById('recordingPreview');
            const stopRecordingBtn = document.getElementById('stopRecording');
            const cancelRecordingBtn = document.getElementById('cancelRecording');
            const useRecordingBtn = document.getElementById('useRecording');
            const discardRecordingBtn = document.getElementById('discardRecording');
            const audioFileInput = document.getElementById('audioFile');

            function updateTimer() {
                // Only update if we're actually recording
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    const now = Date.now();
                    const duration = Math.floor((now - recordingStartTime) / 1000);
                    const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
                    const seconds = (duration % 60).toString().padStart(2, '0');
                    recordingTimer.textContent = `${minutes}:${seconds}`;

                    // Add warning classes based on duration
                    if (duration >= 50 && duration < 55) {
                        recordingTimer.className = 'warning';
                    } else if (duration >= 55) {
                        recordingTimer.className = 'danger';
                    }

                    // Auto-stop at 60 seconds
                    if (duration >= 60) {
                        stopRecording();
                    }
                } else {
                    // If we're not recording, clear the interval
                    clearInterval(timerInterval);
                    recordingTimer.textContent = '00:00';
                    recordingTimer.className = '';
                }
            }

            function startRecording() {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        mediaRecorder = new MediaRecorder(stream);
                        audioChunks = [];
                        
                        mediaRecorder.ondataavailable = e => {
                            audioChunks.push(e.data);
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                            recordedBlob = audioBlob;
                            const audioUrl = URL.createObjectURL(audioBlob);
                            recordingPreview.src = audioUrl;
                            
                            // Show the preview and controls immediately
                            recordingPreview.classList.remove('hidden');
                            previewControls.classList.remove('hidden');
                            
                            // Clear timer when recording stops
                            clearInterval(timerInterval);
                            recordingTimer.textContent = '00:00';
                        };

                        mediaRecorder.start();
                        recordingStartTime = Date.now();
                        // Clear any existing interval before starting a new one
                        if (timerInterval) {
                            clearInterval(timerInterval);
                        }
                        timerInterval = setInterval(updateTimer, 1000);
                        
                        // Update UI
                        micButton.classList.add('recording');
                        recordingStatus.textContent = 'Recording in progress...';
                        recordingTimer.classList.remove('hidden');
                        recordingControls.classList.remove('hidden');
                        recordingPreview.classList.add('hidden');
                        previewControls.classList.add('hidden');
                    })
                    .catch(error => {
                        console.error('Error accessing microphone:', error);
                        alert('Unable to access microphone. Please ensure you have granted permission.');
                    });
            }

            function stopRecording() {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    clearInterval(timerInterval);
                    
                    // Update UI
                    micButton.classList.remove('recording');
                    recordingStatus.textContent = 'Recording complete';
                    recordingTimer.classList.add('hidden');
                    recordingControls.classList.add('hidden');
                }
            }

            function cancelRecording() {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    clearInterval(timerInterval);
                }
                
                // Reset UI
                micButton.classList.remove('recording');
                recordingStatus.textContent = 'Click to start recording';
                recordingTimer.classList.add('hidden');
                recordingControls.classList.add('hidden');
                recordingPreview.classList.add('hidden');
                recordingTimer.className = '';
            }

            // Event Listeners
            micButton.addEventListener('click', function() {
                if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                    startRecording();
                } else if (mediaRecorder && mediaRecorder.state === 'recording') {
                    // If already recording, stop when mic button is clicked again
                    stopRecording();
                }
            });

            stopRecordingBtn.addEventListener('click', stopRecording);
            cancelRecordingBtn.addEventListener('click', cancelRecording);
            
            useRecordingBtn.addEventListener('click', function() {
                if (recordedBlob) {
                    // Create a File object from the Blob
                    const file = new File([recordedBlob], 'recording.wav', { type: 'audio/wav' });
                    
                    // Create a new FileList containing the File
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    
                    // Set the file input's files
                    audioFileInput.files = dataTransfer.files;
                    
                    // Trigger the change event
                    const event = new Event('change');
                    audioFileInput.dispatchEvent(event);
                    
                    // Reset recording UI
                    recordingStatus.textContent = 'Recording selected';
                    previewControls.classList.add('hidden');
                    
                    // Hide the file upload section
                    const fileUploadSection = document.querySelector('#voiceCloneContent > div:nth-child(2)');
                    if (fileUploadSection) {
                        fileUploadSection.style.display = 'none';
                    }
                }
            });
            
            discardRecordingBtn.addEventListener('click', function() {
                cancelRecording();
                recordedBlob = null;
                
                // Show the file upload section again
                const fileUploadSection = document.querySelector('#voiceCloneContent > div:nth-child(2)');
                if (fileUploadSection) {
                    fileUploadSection.style.display = '';
                }
            });
        });

        // Voice cloning form submission handler
        async function submitVoiceCloneForm(e) {
            e.preventDefault();
            
            // Prevent scrolling during form submission
            document.body.style.overflow = 'hidden';
            
            const voiceName = document.getElementById('voiceName').value;
            const voiceDescription = document.getElementById('voiceDescription').value;
            const audioFile = document.getElementById('audioFile').files[0];
            
            if (!audioFile) {
                alert('Please select an audio file or record one');
                document.body.style.overflow = ''; // Restore scrolling
                return;
            }
            
            // Get result elements
            const resultElement = document.getElementById('voiceCloneResult');
            const resultContentElement = document.getElementById('voiceCloneResultContent');
            const loadingSpinner = document.getElementById('voiceLoadingSpinner');
            
            // Show loading spinner
            loadingSpinner.classList.remove('hidden');
            
            // If result is already visible, add refreshing class for transition
            if (!resultElement.classList.contains('hidden')) {
                resultElement.classList.add('refreshing');
                await new Promise(resolve => setTimeout(resolve, 300));
            } else {
                resultElement.classList.remove('hidden');
                resultElement.classList.add('refreshing');
            }
            
            try {
                // Show initial status
                resultContentElement.textContent = 'Checking for existing voices...';
                
                // Get existing voices
                const voicesResponse = await fetch('/voices');
                const voicesData = await voicesResponse.json();
                
                // Check for existing cloned voices
                if (voicesData.results && voicesData.results.length > 0) {
                    const clonedVoices = voicesData.results.filter(voice => voice.type === 'VOICE_TYPE_CLONED');
                    if (clonedVoices.length > 0) {
                        resultContentElement.textContent = 'Deleting existing cloned voices...';
                    }
                }
                
                const formData = new FormData();
                formData.append('name', voiceName);
                if (voiceDescription) {
                    formData.append('description', voiceDescription);
                }
                formData.append('audioFile', audioFile);
                
                console.log('Submitting voice clone form with data:', {
                    name: voiceName,
                    description: voiceDescription,
                    audioFile: audioFile.name
                });
                
                resultContentElement.textContent = 'Creating new voice...';
                
                const response = await fetch('/clone-voice', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    try {
                        const errorJson = JSON.parse(errorText);
                        throw new Error(errorJson.error || errorJson.message || 'Voice cloning failed');
                    } catch (e) {
                        throw new Error(`Voice cloning failed: ${errorText}`);
                    }
                }
                
                const data = await response.json();
                
                // Hide loading spinner
                loadingSpinner.classList.add('hidden');
                
                // Update content
                resultContentElement.textContent = JSON.stringify(data, null, 2);
                
                if (data.error) {
                    resultElement.classList.add('error');
                    resultElement.classList.remove('success');
                } else {
                    resultElement.classList.add('success');
                    resultElement.classList.remove('error');
                    
                    // Refresh voice list
                    await loadVoices();
                }
                
                // Show the result with animation
                setTimeout(() => {
                    resultElement.classList.remove('refreshing');
                    // Restore scrolling
                    document.body.style.overflow = '';
                    
                    // Ensure we don't zoom on mobile
                    if (window.innerWidth <= 768) {
                        // Prevent any zoom by maintaining the viewport scale
                        document.querySelector('meta[name="viewport"]').setAttribute(
                            'content', 
                            'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'
                        );
                    }
                }, 50);
                
            } catch (error) {
                console.error('Error cloning voice:', error);
                
                // Hide loading spinner
                loadingSpinner.classList.add('hidden');
                
                // Update content to show error
                resultContentElement.textContent = 'Error: ' + error.message;
                resultElement.classList.add('error');
                resultElement.classList.remove('success');
                
                // Show the result with animation
                setTimeout(() => {
                    resultElement.classList.remove('refreshing');
                    // Restore scrolling
                    document.body.style.overflow = '';
                }, 50);
            }
        }
    </script>

    <!-- Password Protection Script -->
    <script>
        // Fetch password from server config
        let SECTION_PASSWORD = '';
        
        async function fetchPassword() {
            try {
                console.log('Fetching password from config...');
                const response = await fetch('/config');
                const config = await response.json();
                console.log('Config received:', config);
                SECTION_PASSWORD = config.sectionPassword || 'demo123';
                console.log('Password set:', SECTION_PASSWORD);
                return SECTION_PASSWORD;
            } catch (error) {
                console.error('Error fetching password:', error);
                return 'demo123';
            }
        }

        function setupPasswordProtection(sectionId) {
            console.log('Setting up password protection for:', sectionId);
            const header = document.getElementById(`${sectionId}Header`);
            const protection = document.getElementById(`${sectionId}Protection`);
            const content = document.getElementById(`${sectionId}Content`);
            const unlockBtn = document.getElementById(`${sectionId}Unlock`);
            const passwordInput = document.getElementById(`${sectionId}Password`);
            const errorDiv = document.getElementById(`${sectionId}Error`);
            const lockIcon = header.querySelector('.lock-icon');

            // Check if section was previously unlocked
            const isUnlocked = localStorage.getItem(`${sectionId}Unlocked`) === 'true';
            if (isUnlocked) {
                protection.style.display = 'none';
                content.classList.add('unlocked');
                lockIcon.classList.add('hidden');
            }

            unlockBtn.addEventListener('click', () => {
                console.log('Unlock attempt:', sectionId);
                console.log('Input value:', passwordInput.value);
                console.log('Expected password:', SECTION_PASSWORD);
                if (passwordInput.value === SECTION_PASSWORD) {
                    console.log('Password correct for:', sectionId);
                    protection.style.display = 'none';
                    content.classList.add('unlocked');
                    lockIcon.classList.add('hidden');
                    errorDiv.classList.remove('visible');
                    // Store unlock state
                    localStorage.setItem(`${sectionId}Unlocked`, 'true');
                } else {
                    console.log('Password incorrect for:', sectionId);
                    errorDiv.classList.add('visible');
                    passwordInput.value = '';
                }
            });

            // Also allow Enter key to submit
            passwordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    unlockBtn.click();
                }
            });
        }

        // Set up password protection for both sections
        document.addEventListener('DOMContentLoaded', async () => {
            // First fetch the password
            console.log('Initializing password protection...');
            SECTION_PASSWORD = await fetchPassword();
            console.log('Password initialized:', SECTION_PASSWORD);
            
            // Then set up protection for both sections
            setupPasswordProtection('voiceClone');
            setupPasswordProtection('corpus');
        });
    </script>
</body>
</html> 